// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "builder"
use "doc"
use "gen/markdown"
use "std/jule"
use "std/jule/build"
use "std/jule/parser"
use "std/jule/token"
use "std/os"
use "std/os/filepath"
use "std/strings"

fn writeError(message: str) {
	os::Stderr().WriteStr(message)!
	os::Stderr().WriteByte('\n')!
}

// Derived from the "std/jule/importer", stay up to date.
// Reports whether the arg is exist is distos.
fn checkOs(arg: str): (exist: bool) {
	ret arg == build::DistOS.Windows ||
		arg == build::DistOS.Darwin ||
		arg == build::DistOS.Linux ||
		arg == build::DistOS.Unix
}

// Derived from the "std/jule/importer", stay up to date.
// Reports whether the arg is exist is distarch.
fn checkArch(arg: str): (exist: bool) {
	ret arg == build::DistArch.I386 ||
		arg == build::DistArch.Amd64 ||
		arg == build::DistArch.Arm64 ||
		arg == build::DistArch.X64 ||
		arg == build::DistArch.X32
}

// Derived from the "std/jule/importer", stay up to date.
// Reports whether path is not including any annotation.
fn isPassFileAnnotation(mut p: str): bool {
	p = filepath::Base(p)
	n := len(p)
	p = p[:n-len(filepath::Ext(p))]

	if strings::HasSuffix(p, "_test") {
		ret false
	}

	// a1 is the second annotation.
	// Should be architecture annotation if exist annotation 2 (aka a2),
	// can operating system or architecture annotation if not.
	mut a1 := ""
	// a2 is first filter.
	// Should be operating system filter if exist and valid annotation.
	mut a2 := ""

	// Annotation 1
	mut i := strings::LastIndexByte(p, '_')
	if i == -1 {
		// Check file name directly if not exist any _ character.
		exist := checkOs(p)
		if exist {
			ret false
		}
		ret !checkArch(p)
	}
	if i+1 >= n {
		ret true
	}
	a1 = p[i+1:]

	p = p[:i]

	// Annotation 2
	i = strings::LastIndexByte(p, '_')
	if i != -1 {
		a2 = p[i+1:]
	}

	if a2 == "" {
		exist := checkOs(a1)
		if exist {
			ret false
		}
		ret !checkArch(a1)
	}

	exist := checkArch(a1)
	if exist {
		ret false
	}

	// a1 is not architecture, for this reason bad couple pattern.
	// Accept as one pattern, so a1 can be platform.
	ret !checkOs(a1)
}

// Generates documentation data with path, and returns result.
// If result is nil, we have an error(s).
fn doc(path: str, mut data: []byte): []&doc::Doc {
	mut file := token::Fileset.New(path)
	unsafe { file.FillMut(data) }
	mut errors := token::Lex(file, token::LexMode.Comment)
	if len(errors) > 0 {
		writeError("error: file could not formatted, have error(s): " + path)
		ret nil
	}

	mut cm := builder::BuildCommentMap(file.Tokens)
	mut finfo := parser::ParseFile(file)
	if len(finfo.Errors) > 0 {
		writeError("error: file could not formatted, have error(s): " + path)
		ret nil
	}

	builder := builder::New(finfo.AST, cm)
	ret builder.Build()
}

fn docdoc(mut doc: []&doc::Doc): []byte {
	if len(doc) == 0 {
		ret nil
	}
	mut bytes := markdown::Gen(doc)
	ret bytes
}

fn saveFile(path: str, ctx: []byte) {
	os::File.Write(path, ctx, 0o660) else {
		writeError("error: could not write to file: " + path)
		ret
	}
}

fn docFile(path: str) {
	if !isPassFileAnnotation(path) {
		writeError("error: no symbol to document: " + path)
		ret
	}
	mut doc := doc(path, os::File.Read(path) else {
		writeError("error: file could not read: " + path)
		ret
	})
	bytes := docdoc(doc)
	if bytes == nil {
		writeError("error: no symbol to document: " + path)
	}
}

fn docPackage(path: str) {
	mut dirents := os::Dir.Read(path) else {
		writeError("error: connot read package directory: " + path)
		ret
	}
	mut alldoc := ([]&doc::Doc)(nil)
	for _, dirent in dirents {
		// Skip directories, non-jule files, and files with annotation.
		if dirent.Stat.IsDir() ||
			!strings::HasSuffix(dirent.Name, jule::Ext) ||
			!isPassFileAnnotation(dirent.Name) {
			continue
		}
		filepath := filepath::Join(path, dirent.Name)
		mut doc := doc(filepath, os::File.Read(filepath) else {
			writeError("error: file could not read: " + filepath)
			ret
		})
		alldoc = append(alldoc, doc...)
	}
	bytes := docdoc(alldoc)
	if bytes == nil {
		writeError("error: no symbol to document: " + path)
		ret
	}
	saveFile("output.md", bytes)
}

fn docCommand(path: str) {
	stat := os::Stat.Of(path) else {
		writeError("error: connot read path: " + path)
		ret
	}
	match {
	| stat.IsDir():
		docPackage(path)
		ret
	| stat.IsReg():
		if strings::HasSuffix(path, jule::Ext) {
			docFile(path)
			ret
		}
	}
	writeError("error: path is not supported: " + path)
}

fn main() {
	mut args := os::Args()
	if len(args) > 1 {
		docCommand(args[1])
	}
}