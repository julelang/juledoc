// Copyright 2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Derived from julefmt. Stay up to date.

use "std/bytes"
use "std/jule"
use "std/jule/ast"
use "std/jule/token"
use "std/jule/types"
use "std/slices"
use "std/strings"
use "std/unicode"
use "std/unicode/utf8"

struct field {
	f:     &ast::Field
	token: &token::Token
	tag:   []byte
}

struct rowAlign {
	row: int
	end: int
	col: int
	max: bool
}

struct formatter {
	indentLen: int
	indentStr: str

	mut i:          int
	mut buf:        strings::Builder
	mut f:          &ast::AST
	mut atomIndent: str    // Single indentation
	mut indent:     []byte // Whole indentation based on the current indentation level
	mut cm:         &CommentMap
	mut row:        int

	mut ef: &exprFormatter
}

impl formatter {
	fn new(): &formatter {
		mut fmt := new(formatter)
		fmt.ef = exprFormatter.new(fmt)
		fmt.indentLen = 1
		fmt.indentStr = "\t"
		fmt.atomIndent = strings::Repeat(fmt.indentStr, fmt.indentLen)
		ret fmt
	}

	fn ubuf(self): []byte {
		ret unsafe { self.buf.Buf() }
	}

	fn setBuf(self, mut b: []byte) {
		unsafe { self.buf.SetBuf(b) }
	}

	fn write(&self, s: str) {
		self.buf.WriteStr(s)!
	}

	fn addIndent(&self) {
		self.indent = append(self.indent, self.atomIndent...)
	}

	fn doneIndent(&self) {
		self.indent = self.indent[:len(self.indent)-self.indentLen]
	}

	fn writeComment(&self, &c: &comment) {
		if len(self.indent) > 0 && c.txt[1] == '*' {
			// Range comment should be checked.
			// Ending is should be padded by indentation.
			mut i := utf8::RuneCountStr(c.txt) - 3
		lookup:
			for i > 1; i-- {
				b := c.txt[i]
				match b {
				| ' ' | '\t' | '\v' | '\r':
					continue
				| '\n':
					cmt := c.txt[:i+1]
					i = bytes::LastIndexByte(self.ubuf(), '\n')
					self.write(cmt)
					self.buf.Write(self.indent)!
					self.write("*/")
					ret
				|:
					break lookup
				}
			}
		}
		if c.txt[1] == '/' {
			// Single-line comment, trim trailing spaces before writing.
			self.write(strings::TrimRightFunc(c.txt, unicode::IsSpace))
			ret
		}
		self.write(c.txt)
	}

	fn seekCommentExcept(&self, row: int): &comment {
		for (_, mut c) in self.cm.buf {
			if row != -1 && c.row >= row {
				break
			}
			ret c
		}
		ret nil
	}

	fn writeCommentsExceptL(&self, start: int, row: int, pad: bool, buf: bool): int {
		mut lrow := row
		mut i := 0
		for i < len(self.cm.buf) {
			c := self.cm.buf[i]
			if start != -1 && c.row < start {
				i++
				continue
			} else if row != -1 && c.row >= row {
				break
			}
			if buf && pad && c.row-lrow > 1 {
				self.write("\n")
			}
			lrow = c.row
			self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
			if buf {
				self.buf.Write(self.indent)!
				self.writeComment(c)
				if c.txt[1] == '*' {
					// If comment is range, it might include new-lines.
					// Count them and add to lrow for correct row calculation.
					lrow += strings::Count(c.txt, "\n")
				}
				self.write("\n")
			}
		}
		ret lrow
	}

	fn writeCommentsExcept(&self, row: int, buf: bool): int {
		const Pad = true
		ret self.writeCommentsExceptL(-1, row, Pad, buf)
	}

	fn writeComments(&self, row: int, buf: bool): int {
		ret self.writeCommentsExcept(row+1, buf)
	}

	fn addGlobalPaddingForComment(&self, row: int): bool {
		c := self.cm.first(row)
		if c != nil && c.row-self.row > 1 {
			self.write("\n")
			ret true
		}
		ret false
	}

	fn isPopsRowCommentsByF(self, row: int, col: int): bool {
		mut i := 0
		for i < len(self.cm.buf); i++ {
			c := self.cm.buf[i]
			if c.row == row && (col == -1 || c.col < col) {
				ret true
			} else if c.row > row {
				ret false
			}
		}
		ret false
	}

	fn popRowCommentsUntilByF(&self, row: int, col: int, buf: bool, f: fn(&comment)) {
		mut i := 0
		for i < len(self.cm.buf) {
			c := self.cm.buf[i]
			if c.row > row {
				break
			}
			if col == -1 || c.col < col {
				if buf {
					f(c)
				}
				self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
				continue
			}
			i++
		}
	}

	fn popRowCommentsByF(&self, row: int, col: int, buf: bool, f: fn(&comment)) {
		mut i := 0
		for i < len(self.cm.buf) {
			c := self.cm.buf[i]
			if c.row == row && (col == -1 || c.col < col) {
				if buf {
					f(c)
				}
				self.cm.buf = append(self.cm.buf[:i], self.cm.buf[i+1:]...)
				continue
			} else if c.row > row {
				break
			}
			i++
		}
	}

	fn popRowCommentsBy(&self, row: int, buf: bool) {
		self.popRowCommentsByF(row, -1, buf, fn(c: &comment) {
			self.write(" ")
			self.writeComment(c)
		})
	}

	fn popRowCommentsByC(&self, row: int, col: int, buf: bool) {
		self.popRowCommentsByF(row, col, buf, fn(c: &comment) {
			self.write(c.txt)
			self.write(" ")
		})
	}

	fn popRowComments(&self, row: int, buf: bool) {
		for {
			c := self.cm.pop(row)
			if c == nil {
				break
			}
			if buf {
				self.write(" ")
				self.writeComment(c)
			}
		}
	}

	fn formatExpr(&self, mut &expr: &ast::Expr) {
		self.ef.format(expr)
		self.ef.clean()
	}

	fn formatType(&self, mut &expr: &ast::Expr) {
		self.formatExpr(expr)
	}

	fn directive(&self, &d: &ast::Directive) {
		self.write("#")
		self.write(d.Tag.Kind)
		for i, arg in d.Args {
			match {
			| i == 0:
				self.write(" ")
			| arg.Id != token::RPAREN &&
				d.Args[i-1].Id != token::LPAREN &&
				d.Args[i-1].Id != token::NOT:
				self.write(" ")
			}
			self.write(arg.Kind)
		}
	}

	fn directives(&self, dvs: []&ast::Directive) {
		if len(dvs) == 0 {
			ret
		}
		first := dvs[0]
		if first.Tag.Row-self.writeCommentsExcept(first.Tag.Row, true) > 1 {
			self.write("\n")
		}
		for i, d in dvs {
			if i > 0 {
				self.buf.Write(self.indent)!
			}
			self.writeCommentsExcept(d.Tag.Row, false)
			self.directive(d)
			self.popRowComments(d.Tag.Row, false)
			self.write("\n")
			self.row = d.Tag.Row
		}
	}

	fn generics(&self, mut &g: []&ast::Generic) {
		if len(g) == 0 {
			ret
		}
		self.write("[")
		for (i, mut t) in g {
			self.write(t.Name)
			if t.Constraint != nil {
				self.write(": ")
				for (j, mut c) in t.Constraint.Mask {
					self.formatType(c)
					if len(t.Constraint.Mask)-j > 1 {
						self.write(" | ")
					}
				}
			}
			if i+1 < len(g) {
				self.write(", ")
			}
		}
		self.write("]")
	}

	fn enumItem[T](&self, mut &item: T) {
		const match type T {
		| &ast::EnumItem:
			self.write(item.Name)
			if !item.IsAutoExpr() {
				self.write(": ")
				self.formatExpr(item.X)
			}
		| &ast::TypeEnumItem:
			self.formatType(item.Type)
		}
		self.write(",")
	}

	fn enumDecl[T](&self, mut d: T) {
		self.write("enum ")
		self.write(d.Name)
		const match type T {
		| &ast::Enum:
			if !d.IsDefaultTyped() {
				self.write(": ")
				self.formatType(d.Type)
			}
		| &ast::TypeEnum:
			self.write(": type")
		}
		self.write(" {")
		if len(d.Items) > 0 {
			self.write("\n")
			self.addIndent()
			mut i, mut row := 0, 0
			for i < len(d.Items) {
				old := self.i
				item := d.Items[i]
				const match type T {
				| &ast::Enum:
					self.groupDecls[&ast::EnumItem, &ast::EnumItem](d.Items, i, fn(mut &d: &ast::EnumItem) {
						self.buf.Write(self.indent)!
						self.enumItem[&ast::EnumItem](d)
					})
				| &ast::TypeEnum:
					self.groupDecls[&ast::TypeEnumItem, &ast::TypeEnumItem](d.Items, i, fn(mut &d: &ast::TypeEnumItem) {
						self.buf.Write(self.indent)!
						self.enumItem[&ast::TypeEnumItem](d)
					})
				}
				if i < len(d.Items) {
					if !self.addGlobalPaddingForComment(d.End.Row) && old != i {
						self.write("\n")
					}
				}
				row = item.Token.Row
			}
			self.writeCommentsExcept(d.End.Row, false)
			self.doneIndent()
		}
		self.write("}")
		self.popRowComments(d.End.Row, false)
		self.row = d.End.Row
	}

	fn params(&self, mut &f: &ast::Func) {
		if len(f.Params) == 0 {
			self.write("()")
			ret
		}
		self.write("(")
		mut indented := false
		self.row = f.Token.Row
		for (i, mut p) in f.Params {
			if self.row != p.Token.Row {
				self.write("\n")
				if !indented {
					indented = true
					self.addIndent()
				}
				self.buf.Write(self.indent)!
			} else if i > 0 {
				self.write(" ")
			}
			self.popRowCommentsByC(p.Token.Row, p.Token.Column, false)
			if p.Mutable {
				self.write("mut ")
			}
			if p.Reference {
				self.write("&")
			}
			if p.IsSelf() {
				if p.IsRef() {
					self.write("&")
				}
				self.write("self")
			} else {
				if !jule::IsBlank(p.Name) {
					self.write(p.Name)
					self.write(": ")
				} else if p.Reference {
					self.write("_: ")
				}
				self.popRowCommentsByC(p.Type.Token.Row, p.Type.Token.Column, false)
				if p.Variadic {
					self.write("...")
				}
				self.formatType(p.Type)
			}
			if i+1 < len(f.Params) {
				self.write(",")
				if f.Params[i+1].Token.Row != p.Token.Row {
					self.popRowCommentsByF(p.Token.Row, -1, false, fn(c: &comment) {
						self.write(" ")
						self.writeComment(c)
					})
				}
			}
			self.row = p.Token.Row
		}
		if indented {
			self.doneIndent()
		}
		self.write(")")
	}

	fn result(&self, mut r: &ast::RetType) {
		if len(r.Names) == 0 {
			self.formatType(r.Type)
			ret
		}
		if len(r.Names) == 1 {
			if jule::IsBlank(r.Names[0].Kind) {
				self.formatType(r.Type)
				ret
			}
			self.write("(")
			self.write(r.Names[0].Kind)
			self.write(": ")
			self.formatType(r.Type)
			self.write(")")
			ret
		}
		mut types := r.Type.Data.(&ast::TupleExpr).X
		self.write("(")
		for (i, mut t) in types {
			name := r.Names[i]
			if !jule::IsAnon(name.Kind) {
				self.write(name.Kind)
				self.write(": ")
			}
			self.formatType(t)
			if len(types)-i > 1 {
				self.write(", ")
			}
		}
		self.write(")")
	}

	fn fnDecl(&self, mut d: &ast::Func) {
		if !d.IsAnon() {
			self.writeCommentsExcept(d.Token.Row, true)
			self.buf.Write(self.indent)!
		}
		if len(d.Directives) != 0 {
			self.directives(d.Directives)
			self.buf.Write(self.indent)!
		}
		if d.Bind {
			self.write("cpp ")
		}
		if d.Unsafe {
			self.write("unsafe ")
		}
		self.write("fn")
		if !jule::IsBlank(d.Name) {
			self.write(" ")
			self.write(d.Name)
		}
		self.generics(d.Generics)
		self.params(d)
		if d.Exceptional {
			self.write("!")
		}
		if d.Result.Type != nil {
			self.write(": ")
			self.result(d.Result)
		}
		if d.Scope != nil {
			self.popRowCommentsByC(d.Scope.End.Row, d.Scope.End.Column, false)
			self.popRowComments(d.Scope.End.Row, false)
		}
	}

	// Only parses last field.
	// Leading fields used to calculate maximum declaration length of group for padding.
	fn field(&self, mut f: &field, mut fieldMax: int, mut typeMax: int) {
		self.buf.Write(self.indent)!
		if f.f.Mutable {
			self.write("mut ")
			fieldMax -= 4
		}
		self.write(f.f.Name)
		fieldMax -= utf8::RuneCountStr(f.f.Name)
		self.write(": ")
		if fieldMax > 0 {
			self.write(strings::Repeat(" ", fieldMax))
		}
		n := len(self.ubuf())
		self.formatType(f.f.Type)
		typeMax -= len(self.ubuf()) - n
		if len(f.tag) != 0 {
			if typeMax > 0 {
				self.write(strings::Repeat(" ", typeMax))
			}
			self.write(" ")
			self.buf.Write(f.tag)!
		}
	}

	fn fields(&self, mut &fields: []&ast::Field) {
		if len(fields) == 0 {
			ret
		}
		mut flds := make([]&field, 0, len(fields))
		for (_, mut f) in fields {
			flds = append(flds, &field{
				f: f,
				token: f.Token,
			})
		}
		mut hidden := false
		mut i := 0
		for i < len(flds) {
			old := i
			wr := self.fieldGroupDecls(flds, i)
			hidden = hidden || !wr
			if old != i {
				if wr && i < len(flds) {
					self.write("\n")
				}
			} else {
				i++
			}
		}
		if hidden {
			self.buf.Write(self.indent)!
			self.write("// NOTE: contains filtered hidden or unexported fields\n")
		}
	}

	fn structDecl(&self, mut d: &ast::Struct) {
		if len(d.Directives) != 0 {
			self.directives(d.Directives)
		} else {
			if d.Token.Row-self.writeComments(d.Token.Row, true) > 1 {
				self.write("\n")
			}
		}
		if d.Bind {
			self.write("cpp ")
		}
		self.write("struct ")
		self.write(d.Name)
		self.generics(d.Generics)
		if len(d.Fields) == 0 {
			self.write("{}")
			self.popRowComments(d.End.Row, false)
			ret
		}
		self.write(" {\n")
		self.addIndent()
		self.fields(d.Fields)
		self.addGlobalPaddingForComment(d.End.Row)
		self.writeCommentsExcept(d.End.Row, false)
		self.doneIndent()
		self.write("}")
		self.popRowComments(d.End.Row, false)
		self.row = d.End.Row
	}

	fn traitDecl(&self, mut d: &ast::Trait) {
		self.write("trait ")
		self.write(d.Name)
		if len(d.Methods) == 0 && len(d.Inherits) == 0 {
			self.write("{}")
			self.popRowComments(d.End.Row, false)
			ret
		}
		self.write(" {")
		self.addIndent()
		self.row = d.Token.Row
		for (i, mut ih) in d.Inherits {
			self.write("\n")
			if i > 0 && ih.Token.Row-self.row > 1 {
				self.write("\n")
			}
			self.writeCommentsExcept(ih.Token.Row, true)
			self.buf.Write(self.indent)!
			self.formatType(ih)
			self.popRowComments(ih.Token.Row, false)
			self.row = ih.Token.Row
		}
		if len(d.Inherits) > 0 && len(d.Methods) > 0 {
			if d.Methods[0].Token.Row-self.row > 1 {
				self.write("\n")
			}
		}
		for (i, mut m) in d.Methods {
			self.write("\n")
			if i > 0 && m.Token.Row-self.row > 1 {
				self.write("\n")
			}
			self.writeCommentsExcept(m.Token.Row, true)
			self.fnDecl(m)
			self.popRowComments(m.Token.Row, true)
		}
		// Function declaration formatting won't add new-line.
		// So add a new-line to complete "\n\n" if needed.
		// addGlobalPaddingForComment adds one "\n" if needed.
		pad := self.addGlobalPaddingForComment(d.End.Row) || self.seekCommentExcept(d.End.Row) != nil
		if pad {
			self.write("\n")
		}
		self.writeCommentsExcept(d.End.Row, true)
		self.doneIndent()
		// If padding enabled, there is comment.
		// So comment writer will write a new-line after comment.
		// Avoid to write a new-line after comments.
		if !pad {
			self.write("\n")
		}
		self.write("}")
		self.popRowComments(d.End.Row, true)
		self.row = d.End.Row
	}

	fn typeAliasDecl(&self, mut d: &ast::TypeAlias) {
		if d.Bind {
			self.write("cpp ")
		}
		self.write("type ")
		self.write(d.Name)
		if d.Strict {
			self.write(": ")
		} else {
			self.write(" = ")
		}
		self.formatType(d.Type)
	}

	fn varDecl(&self, mut d: &ast::Var, head: bool, mut counts: [5]int) {
		// Layout of counts.
		mut typeAnnoMax := counts[0]      // maximum name length for type alignment column
		mut nameMax := counts[1]          // maximum name length of the group
		nameMaxHaveType := counts[2] == 1 // whether nameMax owner have type annotation
		mut typeMax := counts[3]          // maximum length of the type annotations
		table := counts[4] == 1           // whether the alignment is like table, column-by-column

		if head {
			if len(d.Directives) != 0 {
				self.directives(d.Directives)
			}
			if d.Bind {
				self.write("cpp let ")
			} else {
				if d.Static {
					self.write("let ")
				} else if d.Const {
					self.write("const ")
				} else if d.Op == nil || d.Op.Id == token::DEFINE {
					self.write("let ")
				}
			}
			if d.Mutable {
				self.write("mut ")
			}
			if d.Reference {
				self.write("&")
			}
		}
		nameLen := utf8::RuneCountStr(d.Name)
		self.write(d.Name)
		self.row = d.Token.Row
		mut typ := 0
		if d.Type != nil {
			self.write(": ")
			// If typeAnnoMax>0, add the missing leading spaces for type annotation.
			if typeAnnoMax > 0 {
				diff := typeAnnoMax - nameLen
				if diff > 0 {
					self.write(strings::Repeat(" ", diff))
				}
			}
			n := len(self.ubuf())
			self.formatType(d.Type)
			typ = utf8::RuneCount(self.ubuf()[n:]) // subtract the runes of type
			self.row = d.Type.Token.Row
		}
		if d.X != nil {
			// If nameMax>0, we have to do alignment.
			if nameMax > 0 {
				// If typeMax>0 and d.Type==nil, we have type alignment.
				// But this variable have not type annotation.
				// Add spaces for the missing ": " part of type annotations.
				if (nameMaxHaveType || table) && typeMax > 0 && d.Type == nil {
					nameMax += 2
				}
				// If the maximum name have not type annotation and this variable have,
				// remove the spaces of the ": " part of type annotations.
				if !nameMaxHaveType && d.Type != nil {
					nameMax -= 2
				}
				// If we have type alignment and this variable have type annotation,
				// add missing trailing spaces to reach maximum type annotation length.
				if typeMax > 0 && d.Type != nil {
					diff := typeMax - typ
					if diff > 0 {
						self.write(strings::Repeat(" ", diff))
					}
					// Remove the added spaces from alignment.
					nameMax -= diff
				}
				// Remove the spaces of type annotation length of this variable.
				nameMax -= typ
				// If type annotation alignemnt exist and this variable have type annotation,
				// remove the spaces of annotation alignment, because type annotation is aligned.
				// Otherwise, remove spaces for name length,
				// there are still missing spaces for type annotations.
				if typeAnnoMax > 0 && d.Type != nil {
					nameMax -= typeAnnoMax
				} else {
					nameMax -= nameLen
				}
				if nameMax > 0 {
					self.write(strings::Repeat(" ", nameMax))
				}
			}
			self.write(" ")
			self.write(d.Op.Kind)
			self.write(" ")
			self.formatExpr(d.X)
			self.row = d.X.End.Row
		}
	}

	fn getMax(self, lines: [][]byte, rows: []int): (max: int, n: int) {
		if len(lines) == 0 || len(rows) == 0 {
			ret 0, 0
		}
		if !self.isPopsRowCommentsByF(rows[0], -1) {
			ret
		}
		max = utf8::RuneCount(lines[0])
		n = 1
		for n < len(lines); n++ {
			if rows[n-1] == rows[n] || !self.isPopsRowCommentsByF(rows[n], -1) {
				break
			}
			diff := utf8::RuneCount(lines[n])
			if max < diff {
				max = diff
			}
		}
		ret
	}

	// Reports whether all fields is actually written.
	fn fieldGroupDecls(&self, mut fields: []&field, mut &i: int): (wr: bool) {
		mut lines := make([][]byte, 0, len(fields))
		mut rows := make([]int, 0, len(fields))

		mut start := i
		self.row = -1
		mut fieldMax := 0
		mut typeMax := 0
		mut n := self.buf.Len()
		for i < len(fields) {
			mut decl := fields[i]
			row := self.row // save the first row data to after use
			// If the row is not first, compare current row with the previous one.
			// If the difference greatest than one row, end the iteration.
			if row != -1 && decl.token.Row-rows[(i-start)-1] > 1 {
				break
			}
			self.row = decl.token.Row
			mut fm := 0
			if decl.f.Mutable {
				fm += len("mut ")
			}
			fm += utf8::RuneCountStr(decl.f.Name)
			self.formatType(decl.f.Type)
			tm := utf8::RuneCount(self.ubuf()[n:])
			self.setBuf(self.ubuf()[:n])
			if row != -1 && decl.token.Row != self.row {
				break
			}
			if decl.f.Tag != nil {
				self.write(decl.f.Tag.Kind)
				decl.tag = cloneBuf(self.ubuf()[n:])
				self.setBuf(self.ubuf()[:n])
			}
			if row != -1 && decl.token.Row != self.row {
				break
			}
			rows = append(rows, decl.token.Row)
			if fm > fieldMax {
				fieldMax = fm
			}
			if tm > typeMax {
				typeMax = tm
			}
			i++
		}

		mut j := start
		for j < i; j++ {
			mut f := fields[j]
			self.field(f, fieldMax, typeMax)
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			self.setBuf(self.ubuf()[:n])
		}

		wr = true
		n = 0
		mut max := 0
		for k, line in lines {
			row := rows[k]
			isPub := isPub(fields[start+k].f.Name) // Ignore private fields.
			wr = wr && isPub
			self.writeCommentsExcept(row, isPub)
			if isPub {
				self.buf.Write(line)!
			}
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-k < 2 || rows[k] != rows[k+1] {
				if n == 0 {
					max, n = self.getMax(lines[k:], rows[k:])
				}
				if n > 0 {
					self.popRowCommentsByF(row, -1, isPub, fn(c: &comment) {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					})
					n--
				}
			}
			if isPub {
				self.write("\n")
			}
		}

		ret
	}

	fn varSubGroup(&self, mut vars: []&ast::Var, mut &i: int) {
		// Do not increase the i, because all grouped variables are represented by the root.
		mut lines := make([][]byte, 0, len(vars[i:]))
		mut rows := make([]int, 0, len(vars[i:]))
		mut counts := make([][2]int, 0, len(vars[i:]))

		start := i
		mut n := self.buf.Len()

		// Returns maximum length of identifiers for type annotation alignment.
		// j is the current varaible.
		getTypeAnnoMax := fn(mut j: int): (nameMax: int) {
			counts = counts[:unsafe { i }-start] // use all capacity of counts
			for j > start {
				v := vars[j-1]
				if v.Type != nil {
					j--
				} else {
					break
				}
			}
			for j < unsafe { i }; j++ {
				mut v := vars[j]
				if !isPub(v.Name) {
					continue
				}
				if v.Type != nil {
					name := counts[j-start][0]
					if name > nameMax {
						nameMax = name
					}
				} else {
					break
				}
			}
			ret
		}

		// Returns maximum length of assignment alignment.
		// j is the current varaible
		getAssignMax := fn(mut j: int, mut &typeAnnoMax: int): (nameMax: int, nameMaxHaveType: int, typeMax: int, table: int) {
			counts = counts[:unsafe { i }-start] // use all capacity of counts
			for j > start {
				v := vars[j-1]
				if v.X != nil || self.isPopsRowCommentsByF(v.Token.Row, -1) {
					j--
				} else {
					break
				}
			}
			mut fullComment := true // whether the all group members have comment
			mut maxPlainName := 0
			mut maxNameWithType := typeAnnoMax
			for j < unsafe { i }; j++ {
				mut v := vars[j]
				if !isPub(v.Name) {
					continue
				}
				comment := self.isPopsRowCommentsByF(v.Token.Row, -1)
				if v.X == nil && !comment {
					break
				}
				fullComment = fullComment && comment
				c := counts[j-start]
				t := c[0]
				if maxPlainName < t {
					maxPlainName = t
				}
				if v.Type != nil {
					if maxNameWithType < t {
						maxNameWithType = t
					}
				}
				if c[1] > typeMax {
					typeMax = c[1]
				}
			}
			if fullComment {
				table = 1
				// typeAnnoMax must strore the maximum length of the group for type alignment.
				typeAnnoMax = maxNameWithType
				if typeAnnoMax < maxPlainName {
					typeAnnoMax = maxPlainName
				}
				// add typeMax to maxPlainName for type alignment.
				// Because all the group must be aligned column-by-column.
				maxPlainName += typeMax
			}
			maxNameWithType += typeMax
			maxNameWithType += 2 // add space for ": " part of type annotation
			if maxNameWithType > maxPlainName {
				maxNameWithType -= 2 // remove space for ": " part of type annotation
				nameMax = maxNameWithType
				nameMaxHaveType = 1
			} else {
				nameMax = maxPlainName
				nameMaxHaveType = 0
			}
			ret
		}

		self.row = -1
		for i < len(vars); i++ {
			mut v := vars[i]
			if !isPub(v.Name) {
				continue
			}
			row := self.row // save the first row data to after use
			// If the row is not first, compare current row with the previous one.
			// If the difference greatest than one row, end the iteration.
			if row != -1 && v.Token.Row-vars[i-1].Token.Row > 1 {
				break
			}
			self.row = v.Token.Row
			mut name := utf8::RuneCountStr(v.Name)
			mut typ := 0
			if v.Type != nil {
				self.formatType(v.Type)
				typ = utf8::RuneCount(self.ubuf()[n:])
				self.setBuf(self.ubuf()[:n])
				if row != -1 && v.Token.Row != self.row {
					break
				}
			}
			if v.X != nil {
				self.formatExpr(v.X)
				self.setBuf(self.ubuf()[:n])
				if row != -1 && v.Token.Row != self.row {
					break
				}
			}
			counts = append(counts, [name, typ])
		}
		mut z := start
		for z < i; z++ {
			mut typeAnnoMax := getTypeAnnoMax(z)
			nameMax, nameMaxHaveType, typeMax, table := getAssignMax(z, typeAnnoMax)
			self.varDecl(vars[z], false, [typeAnnoMax, nameMax, nameMaxHaveType, typeMax, table])
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			rows = append(rows, self.row)
			self.setBuf(self.ubuf()[:n])
		}
		n = 0
		mut max := 0
		mut rowBreak := indexRowBrake(rows)
		for j, line in lines {
			isPub := isPub(vars[start+j].Name) // Ignore private ones.
			row := rows[j]
			if j == rowBreak {
				self.write("\n")
				rowBreak = j + indexRowBrake(rows[j:])
			}
			self.writeCommentsExcept(row, isPub)
			if isPub {
				self.buf.Write(self.indent)!
				self.buf.Write(line)!
			}
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-j < 2 || rows[j] != rows[j+1] {
				if n == 0 {
					max, n = self.getMax(lines[j:rowBreak], rows[j:rowBreak])
				}
				if n > 0 {
					self.popRowCommentsByF(row, -1, isPub, fn(c: &comment) {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					})
					n--
				}
			}
			if isPub {
				self.write("\n")
			}
		}
		self.row = rows[len(rows)-1] + 1 // Add +1 offset for "\n)" suffix.
	}

	fn varGroup(&self, mut root: &ast::Var) {
		self.buf.Write(self.indent)!
		self.write("const (\n")
		self.addIndent()
		mut j := 0
		for j < len(root.Group) {
			old := j
			self.varSubGroup(root.Group, j)
			if old != j {
				if j < len(root.Group) {
					self.write("\n")
				}
			} else {
				j++
			}
		}
		self.doneIndent()
		self.buf.Write(self.indent)!
		self.write(")")
	}

	fn groupDecls[T, Node](&self, mut nodes: []Node, mut &i: int, writer: fn(mut &d: T)) {
		if len(nodes) == 0 {
			ret
		}

		// If group declaration used, fall-back to special group handling.
		const match type T {
		| &ast::Var:
			const match type Node {
			| &ast::Var:
				if nodes[i].Group != nil {
					self.varGroup(nodes[i])
					ret
				}
			| ast::Node | ast::Stmt:
				mut v, ok := nodes[i].Data.(T)
				if ok && v.Group != nil {
					self.varGroup(v)
					ret
				}
			}
		| ast::Node | ast::Stmt:
			mut v, ok := nodes[i].Data.(&ast::Var)
			if ok && v.Group != nil {
				self.varGroup(v)
				ret
			}
		}

		const Cap = 1 << 4
		mut lines := make([][]byte, 0, Cap)
		mut rows := make([]int, 0, Cap)

		all := i == -1
		if all {
			i = 0
		}

		self.row = -1
		mut n := self.buf.Len()
	loop:
		for i < len(nodes) {
			let mut decl: T
			mut row := -1
			const match type Node {
			| &ast::EnumItem
			| &ast::TypeEnumItem:
				decl = nodes[i]
				row = decl.Token.Row
			| ast::Node:
				node := nodes[i]
				match type node.Data {
				| T:
					decl = nodes[i].Data.(T)
					row = decl.Token.Row
				|:
					break loop
				}
			|:
				panic("groupDecls: unimplemented type")
			}
			if !all && self.row != -1 && row-self.row > 1 {
				break loop
			}
			self.row = row
			writer(decl)
			mut line := cloneBuf(self.ubuf()[n:])
			lines = append(lines, line)
			rows = append(rows, self.row)
			self.setBuf(self.ubuf()[:n])
			i++
			const match type Node {
			| ast::Stmt:
				if decl.Token.Row != decl.End.Row {
					// break if start row and end row is not same of stmt
					break loop
				}
			}
		}

		n = 0
		mut max := 0
		for j, line in lines {
			row := rows[j]
			wr := len(line) > 0 // Do not write empty lines.
			self.writeCommentsExcept(row, wr)
			if wr {
				self.buf.Write(line)!
			}
			// Handle comments if same-line condition is not appear or
			// current row is not same as next row. So, we can move line comments
			// to last statement of inline statements.
			if len(lines)-j < 2 || rows[j] != rows[j+1] {
				if n == 0 {
					max, n = self.getMax(lines[j:], rows[j:])
				}
				if n > 0 {
					self.popRowCommentsByF(row, -1, wr, fn(c: &comment) {
						self.write(strings::Repeat(" ", paddingAbs(max-utf8::RuneCount(line))+1))
						self.writeComment(c)
					})
					n--
				}
			}
			if wr {
				self.write("\n")
			}
		}
	}

	fn node(&self, mut &node: ast::Node) {
		match type node.Data {
		| &ast::TypeAlias:
			mut d := node.Data.(&ast::TypeAlias)
			self.writeCommentsExcept(d.Token.Row, true)
			self.typeAliasDecl(d)
			ret
		| &ast::Var:
			mut d := node.Data.(&ast::Var)
			if len(d.Directives) > 0 {
				self.writeCommentsExcept(d.Directives[0].Tag.Row, true)
			} else {
				self.writeCommentsExcept(d.Token.Row, true)
			}
			if d.Group != nil {
				self.varGroup(d)
			} else {
				self.varDecl(d, true, [])
			}
			ret
		| &ast::Func:
			mut d := node.Data.(&ast::Func)
			if len(d.Directives) > 0 {
				self.writeCommentsExcept(d.Directives[0].Tag.Row, true)
			} else {
				self.writeCommentsExcept(d.Token.Row, true)
			}
			self.fnDecl(d)
			ret
		| &ast::Struct:
			mut d := node.Data.(&ast::Struct)
			if len(d.Directives) > 0 {
				self.writeCommentsExcept(d.Directives[0].Tag.Row, true)
			} else {
				self.writeCommentsExcept(node.Token.Row, true)
			}
			self.structDecl(d)
		|:
			// no-op
		}
		if node.Token.Row-self.writeComments(node.Token.Row, true) > 1 {
			self.write("\n")
		}
		match type node.Data {
		| &ast::Enum:
			self.enumDecl[&ast::Enum](node.Data.(&ast::Enum))
		| &ast::TypeEnum:
			self.enumDecl[&ast::TypeEnum](node.Data.(&ast::TypeEnum))
		| &ast::Trait:
			self.traitDecl(node.Data.(&ast::Trait))
		|:
			// no-op
		}
	}
}

struct exprFormatter {
	mut fmt: &formatter
	mut bf:  &binaryFormatter

	// Ignore begin comments.
	// It will skips comments for begin.
	// Useful for slice literal elements.
	mut ibc: bool
}

impl exprFormatter {
	fn new(&fmt: &formatter): &exprFormatter {
		mut ef := &exprFormatter{
			fmt: unsafe { *(&fmt) },
		}
		ef.bf = &binaryFormatter{
			ef: ef,
		}
		ret ef
	}

	fn write(&self, s: str) {
		self.fmt.buf.WriteStr(s)!
	}

	fn clean(&self) {
		self.bf.clean()
	}

	fn tuple(&self, mut tup: &ast::TupleExpr) {
		for (i, mut expr) in tup.X {
			self.format(expr)
			if i+1 < len(tup.X) {
				self.write(", ")
			}
		}
	}

	fn sliceType(&self, mut slc: &ast::SliceType) {
		self.write("[]")
		self.formatKind(slc.Value.Data)
	}

	fn arrayType(&self, mut arr: &ast::ArrayType) {
		self.write("[")
		if arr.IsAutoSized() {
			self.write("...")
		} else {
			self.fmt.formatExpr(arr.Size)
		}
		self.write("]")
		self.formatKind(arr.Value.Data)
	}

	fn mapType(&self, mut m: &ast::MapType) {
		self.write("map[")
		self.formatKind(m.Key.Data)
		self.write("]")
		self.formatKind(m.Value.Data)
	}

	fn chanType(&self, mut c: &ast::ChanType) {
		if c.Dir&(ast::RECV|ast::SEND) == ast::RECV|ast::SEND {
			self.write("chan ")
		} else if c.Dir&ast::RECV == ast::RECV {
			self.write("<-chan ")
		} else {
			self.write("chan<- ")
		}
		self.format(c.Value)
	}

	fn lit(&self, l: &ast::LitExpr) {
		self.write(l.Value)
	}

	fn unsafexpr(&self, mut u: &ast::UnsafeExpr) {
		self.write("unsafe {")
		line := u.X.Token.Row != u.X.End.Row
		if line {
			self.fmt.addIndent()
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		} else {
			self.write(" ")
		}
		self.format(u.X)
		if line {
			self.fmt.doneIndent()
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		} else {
			self.write(" ")
		}
		self.write("}")
	}

	fn name(&self, id: &ast::NameExpr) {
		if id.Bind {
			self.write("cpp.")
		}
		self.write(id.Name)
	}

	fn unary(&self, mut u: &ast::UnaryExpr) {
		if u.IsUnsafePtr() {
			self.write("*unsafe")
			ret
		}
		self.write(u.Op.Kind)
		self.format(u.X)
	}

	fn variadic(&self, mut v: &ast::VariadicExpr) {
		self.format(v.X)
		self.write("...")
	}

	fn namespace(&self, ns: &ast::NamespaceExpr) {
		self.write(ns.Namespace.Kind)
		self.write("::")
		self.write(ns.Name.Kind)
	}

	fn selector(&self, mut si: &ast::SelectorExpr) {
		self.format(si.X)
		self.write(".")
		if self.fmt.row != si.Name.Row {
			self.fmt.addIndent()
			defer { self.fmt.doneIndent() }
			self.write("\n")
			self.fmt.buf.Write(self.fmt.indent)!
		}
		self.write(si.Name.Kind)
		self.fmt.row = si.Name.Row
	}

	fn binary(&self, mut bin: &ast::BinaryExpr) {
		self.bf.new(bin)
		self.bf.binary(bin)
	}

	fn args(&self, mut &f: &ast::CallExpr) {
		if len(f.Args) == 0 {
			ret
		}

		// Save the indentation for the SubIdentExpr.
		// Arguments should be handled in this indentation.
		// But exceptional call handler scopes must avoid this indentation.
		//
		// Respect this kind of expression:
		//	foo.
		//		Bar().
		//		Baz(
		//			"foo",
		//			"bar",
		//			"baz") else {
		//		println("error handling...")
		//	}
		sie, _ := f.Func.Data.(&ast::SelectorExpr)
		if sie != nil && sie.X.Token.Row != sie.Name.Row {
			self.fmt.addIndent()
			defer { self.fmt.doneIndent() }
		}

		// save state of zip mode
		zip := self.bf.zip
		self.bf.zip = self.bf.zip || len(f.Args) > 1 // enable zip mode if arguments more than one

		mut row := self.fmt.row
		mut indented := false
		for (i, mut arg) in f.Args {
			if i > 0 {
				self.write(",")
			}
			if row != arg.Token.Row {
				if !indented {
					indented = true
					self.fmt.addIndent()
				}
				const Pad = true
				self.fmt.writeCommentsExceptL(arg.Token.Row, arg.Token.Row, Pad, false)
				self.write("\n")
				self.fmt.buf.Write(self.fmt.indent)!
			} else if i > 0 {
				self.write(" ")
			}
			self.fmt.popRowCommentsByC(arg.Token.Row, arg.Token.Column, false)
			self.format(arg)
			self.fmt.popRowCommentsByC(arg.Token.Row, arg.Token.Column, false)
			row = self.fmt.row
		}
		if indented {
			self.fmt.doneIndent()
		}

		// save zip mode
		self.bf.zip = zip
	}

	fn call(&self, mut f: &ast::CallExpr) {
		self.fmt.row = f.Token.Row
		if f.IsCo {
			self.write("co ")
		}
		parent := isParentNeededForCall(f.Func)
		if parent {
			self.write("(")
		}
		self.format(f.Func)
		if parent {
			self.write(")")
		}
		self.write("(")
		self.args(f)
		self.write(")")
		if f.Ignored() {
			self.write("!")
		} else if f.Exception != nil {
			self.write(" else { ... }")
			self.fmt.row = f.Exception.End.Row
		}
	}

	fn slicing(&self, mut i: &ast::SlicingExpr) {
		zip := self.bf.zip
		defer { self.bf.zip = zip }

		mut lb, mut rb, mut cb := false, false, false
		lr, rr, cr := isRanged(i.Low), isRanged(i.High), isRanged(i.Max)
		if !lr && i.Low != nil {
			_, isBinary := i.Low.Data.(&ast::BinaryExpr)
			if isBinary {
				lb = true
			}
		}
		if !rr && i.High != nil {
			_, isBinary := i.High.Data.(&ast::BinaryExpr)
			if isBinary {
				rb = true
			}
		}
		if !cr && i.Max != nil {
			_, isBinary := i.Max.Data.(&ast::BinaryExpr)
			if isBinary {
				cb = true
			}
		}

		self.format(i.X)
		self.write("[")

		self.bf.zip = zip || !lr
		self.format(i.Low)

		padding := !zip && (lb || rb || cb)
		if padding && i.Low != nil && i.High != nil {
			self.write(" : ")
		} else if padding && i.Low == nil && i.Max != nil {
			self.write(": ")
		} else {
			self.write(":")
		}

		self.bf.zip = zip || !rr
		self.format(i.High)

		if i.Max != nil {
			if padding {
				self.write(" : ")
			} else {
				self.write(":")
			}
			self.bf.zip = zip || !cr
			self.format(i.Max)
		}

		self.write("]")
	}

	fn chanSend(&self, mut c: &ast::ChanSend) {
		self.fmt.formatExpr(c.Chan)
		self.write(" <- ")
		self.fmt.formatExpr(c.X)
	}

	fn typeAssertion(&self, mut a: &ast::TypeAssertionExpr) {
		self.fmt.formatExpr(a.X)
		self.write(".(")
		self.fmt.formatType(a.Type)
		self.write(")")
	}

	fn formatKind(&self, mut &kind: ast::ExprData) {
		match type kind {
		| &ast::RangeExpr:
			mut expr := kind.(&ast::RangeExpr)
			self.write("(")
			self.formatKind(expr.X.Data)
			self.write(")")
		| &ast::Func:
			mut f := kind.(&ast::Func)
			self.fmt.fnDecl(f)
			self.fmt.write(" { ... }")
		| &ast::NameExpr:
			self.name(kind.(&ast::NameExpr))
		| &ast::TupleExpr:
			self.tuple(kind.(&ast::TupleExpr))
		| &ast::LitExpr:
			self.lit(kind.(&ast::LitExpr))
		| &ast::UnsafeExpr:
			self.unsafexpr(kind.(&ast::UnsafeExpr))
		| &ast::UnaryExpr:
			self.unary(kind.(&ast::UnaryExpr))
		| &ast::VariadicExpr:
			self.variadic(kind.(&ast::VariadicExpr))
		| &ast::NamespaceExpr:
			self.namespace(kind.(&ast::NamespaceExpr))
		| &ast::SelectorExpr:
			self.selector(kind.(&ast::SelectorExpr))
		| &ast::BinaryExpr:
			self.binary(kind.(&ast::BinaryExpr))
		| &ast::CallExpr:
			self.call(kind.(&ast::CallExpr))
		| &ast::KeyValueExpr:
			self.write("{...:...}")
		| &ast::TypedBraceLit:
			mut lit := kind.(&ast::TypedBraceLit)
			self.fmt.formatType(lit.Type)
			fall
		| &ast::BraceLit:
			self.write("{ ... }")
		| &ast::SliceExpr:
			self.write("[ ... ]")
		| &ast::IndexExpr:
			mut i := kind.(&ast::IndexExpr)
			self.format(i.X)
			self.write("[ ... ]")
		| &ast::SlicingExpr:
			self.slicing(kind.(&ast::SlicingExpr))
		| &ast::ChanSend:
			self.chanSend(kind.(&ast::ChanSend))
		| &ast::TypeAssertionExpr:
			self.typeAssertion(kind.(&ast::TypeAssertionExpr))
		| &ast::SliceType:
			self.sliceType(kind.(&ast::SliceType))
		| &ast::ArrayType:
			self.arrayType(kind.(&ast::ArrayType))
		| &ast::MapType:
			self.mapType(kind.(&ast::MapType))
		| &ast::ChanType:
			self.chanType(kind.(&ast::ChanType))
		}
	}

	fn format(&self, mut &expr: &ast::Expr) {
		if expr == nil {
			ret
		}
		self.fmt.row = expr.Token.Row
		self.formatKind(expr.Data)
		self.fmt.row = expr.End.Row
	}
}

struct binaryFormatter {
	mut ef:   &exprFormatter
	mut zip:  bool
	mut op:   bool // result of [binaryFormatter.isOp]
	mut prec: bool // spacing by operator format precedence
	mut bin:  &ast::BinaryExpr
}

impl binaryFormatter {
	// Reports whether operator should take space for formatting.
	fn isOp(op: int): bool {
		ret op == token::LOR ||
			op == token::LAND ||
			op == token::GTR ||
			op == token::LSS ||
			op == token::LEQ ||
			op == token::GEQ ||
			op == token::EQL ||
			op == token::NEQ
	}

	// Reports whether the operator is have high formatting precedence.
	// Returns 1 for high precedence, otherwise returns 0.
	fn opPrec(op: int): int {
		match op {
		| token::SHL
		| token::SHR
		| token::MUL
		| token::QUO
		| token::REM
		| token::AND:
			ret 1
		|:
			ret 0
		}
	}

	// Reports whether operator zips operands.
	fn isHardZipOp(op: int): bool {
		ret op == token::LOR ||
			op == token::LAND
	}

	fn write(&self, s: str) {
		self.ef.write(s)
	}

	fn clean(&self) {
		self.zip = false
		self.op = false
		self.prec = false
		self.bin = nil
	}

	// writes space for operator if possible
	fn writeSpace(&self) {
		if self.op {
			self.write(" ")
			ret
		}
		// operator is not op

		if self.zip {
			// zip mode on following detection is disallowed
			ret
		}
		// zip mode is off

		if !self.prec {
			// prec mode is off
			self.write(" ")
			ret
		}
		// prec mode is on

		// write space if operator is not precedenced
		if binaryFormatter.opPrec(self.bin.Op.Id) == 0 {
			self.write(" ")
		}
	}

	fn head(&self, mut &bin: &ast::BinaryExpr) {
		self.ef.fmt.popRowCommentsByC(bin.X.Token.Row, bin.X.Token.Column, false)
		self.format(bin.X)
		self.op = binaryFormatter.isOp(bin.Op.Id)
		self.writeSpace()
		self.ef.fmt.popRowCommentsByC(bin.Op.Row, bin.Op.Column, false)
		self.write(bin.Op.Kind)
	}

	fn binary(&self, mut bin: &ast::BinaryExpr) {
		self.bin = bin
		self.head(self.bin)
		if self.bin.Op.Row == self.bin.Y.Token.Row {
			self.writeSpace()
			self.ef.fmt.popRowCommentsByC(self.bin.Y.Token.Row, self.bin.Y.Token.Column, false)
			self.format(self.bin.Y)
			ret
		}
		self.ef.fmt.addIndent()
		self.ef.fmt.popRowCommentsBy(self.bin.Op.Row, false)
		self.write("\n")
		self.ef.fmt.buf.Write(self.ef.fmt.indent)!
		self.ef.fmt.popRowCommentsByC(self.bin.Y.Token.Row, self.bin.Y.Token.Column, false)
		match type self.bin.Y.Data {
		| &ast::BinaryExpr:
			bin = self.bin.Y.Data.(&ast::BinaryExpr)
			if self.bin.Op.Row != self.bin.Y.Token.Row {
				self.binary(bin)
				self.ef.fmt.doneIndent()
			} else {
				self.ef.fmt.doneIndent()
				self.binary(bin)
			}
		|:
			self.format(self.bin.Y)
			self.ef.fmt.row = self.bin.Y.Token.Row
			self.ef.fmt.doneIndent()
		}
	}

	fn isZip(&self, mut &kind: ast::ExprData): bool {
		match type kind {
		| &ast::BinaryExpr:
			mut bin := kind.(&ast::BinaryExpr)
			if binaryFormatter.isHardZipOp(bin.Op.Id) {
				ret true
			}
			ret self.isZip(bin.X.Data) || self.isZip(bin.Y.Data)
		|:
			ret false
		}
	}

	fn isPrec(&self, first: int, &kind: ast::ExprData): int {
		match type kind {
		| &ast::BinaryExpr:
			bin := kind.(&ast::BinaryExpr)
			if first != binaryFormatter.opPrec(bin.Op.Id) {
				ret -1
			}
			mut prec := self.isPrec(first, bin.X.Data)
			if first != prec {
				ret -1
			}
			prec = self.isPrec(first, bin.Y.Data)
			if first != prec {
				ret -1
			}
			ret first
		|:
			ret first
		}
	}

	fn new(&self, mut &bin: &ast::BinaryExpr) {
		if self.zip {
			ret
		}
		// detect zip
		if binaryFormatter.isOp(bin.Op.Id) {
			self.zip = true
			ret
		}
		self.zip = self.isZip(bin.X.Data) || self.isZip(bin.Y.Data)
		if self.zip {
			// skip if zipped, no need to detect following
			ret
		}

		// detect prec
		if !self.prec {
			// enable prec formatting if all operators is not have same prec
			first := binaryFormatter.opPrec(bin.Op.Id)
			self.prec = first != self.isPrec(first, bin.X.Data) || first != self.isPrec(first, bin.Y.Data)
		}
	}

	// Formats expression.
	// It designed for binary expressions operands only.
	fn format(&self, mut &expr: &ast::Expr) {
		if expr == nil {
			ret
		}

		// store state of internal data
		zip := self.zip
		prec := self.prec
		mut bin := self.bin

		// format expression
		match type expr.Data {
		| &ast::BinaryExpr:
			// keep prec mode for tail
			break
		| &ast::CallExpr:
			self.zip = true

			// disable prec mode for non-tail expressions
			self.prec = false
		|:
			// enable zip mode if prec mode is enabled and
			// current binary operator have high precedence
			self.zip = self.zip || self.prec && binaryFormatter.opPrec(self.bin.Op.Id) == 1

			// disable prec mode for non-tail expressions
			self.prec = false
		}
		self.ef.format(expr)

		// save internal data
		self.zip = zip
		self.bin = bin
		self.prec = prec
	}
}

fn paddingAbs(x: int): int {
	if x < 0 {
		ret 0
	}
	ret x
}

fn isPrimType(&t: &ast::Expr): bool {
	name, ok := t.Data.(&ast::NameExpr)
	ret ok && name.Name == types::I8 ||
		name.Name == types::I16 ||
		name.Name == types::I32 ||
		name.Name == types::I64 ||
		name.Name == types::U8 ||
		name.Name == types::U16 ||
		name.Name == types::U32 ||
		name.Name == types::U64 ||
		name.Name == types::Int ||
		name.Name == types::Uint ||
		name.Name == types::Uintptr ||
		name.Name == types::F32 ||
		name.Name == types::F64 ||
		name.Name == types::Bool ||
		name.Name == types::Str ||
		name.Name == types::Any
}

fn isRanged(&e: &ast::Expr): bool {
	if e == nil {
		ret false
	}
	_, ok := e.Data.(&ast::RangeExpr)
	ret ok
}

fn cloneBuf(b: []byte): []byte {
	mut rb := make([]byte, len(b))
	copy(rb, b)
	ret rb
}

fn indexRowBrake(rows: []int): int {
	for i, r in rows {
		if i > 0 && r-rows[i-1] > 1 {
			ret i
		}
	}
	ret len(rows)
}

fn isParentNeededForCall(expr: &ast::Expr): bool {
	f, _ := expr.Data.(&ast::Func)
	ret f != nil && f.IsDecl()
}