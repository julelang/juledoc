// Copyright 2025 The Jule Project Contributors. All rights reserved.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "juledoc/doc"
use "std/strings"
use "std/unicode"

struct ctxBuilder {
	mut lines:  []str
	mut i:      int
	mut indent: int
}

impl ctxBuilder {
	fn text(*self): doc::Text {
		mut txt := strings::Builder{}

		// Handle the first line with not whitespace trim.
		// It will be trimmed if needed.
		// This is mandatory to keep whitespaces of subscopes.
		mut line, indent, _ := handleDocLine(self.lines[self.i], false)

		// Enable whitespace trim mode if indentation is main-scope.
		trimWS := indent == 0

		// If whitespace trimming is needed, trim whitespaces of the first line.
		if trimWS {
			line = strings::Trim(line, " ")
		}

		// Append the first line.
		txt.WriteStr(line)!

		self.i++ // Skip current line.
		for self.i < len(self.lines); self.i++ {
			newLine, newIndent, _ := handleDocLine(self.lines[self.i], trimWS)
			// Separator.
			if len(newLine) == 0 {
				break
			}
			// Indentation is not compatible.
			if indent != newIndent {
				break
			}
			// Concat lines if indent is zero,
			// otherwise split lines into other doc::Text instances.
			if indent == 0 {
				// Line is list item. Do not append, break.
				if len(isList(newLine)) > 0 {
					break
				}
				txt.WriteByte(' ')!
				txt.WriteStr(newLine)!
				continue
			}
			break
		}
		ret doc::Text(txt.Str())
	}

	fn list(*self, mut line: str, mark: str): doc::ListItem {
		mut txt := strings::Builder{}
		listctx := line[len(mark):]                // Line with no list mark.
		txt.WriteStr(strings::TrimSpace(listctx))! // Add text with no list mark.
		self.i++                                   // Skip current line.
		// If possible, concat following lines.
		for self.i < len(self.lines); self.i++ {
			(line), indent, tws := handleDocLine(self.lines[self.i], true)
			// Separator, new list item or a different node
			// which is breaks the list.
			if len(line) == 0 || indent < 0 && tws < 2 || len(isList(line)) > 0 {
				break
			}

			txt.WriteByte(' ')!
			txt.WriteStr(line)!
		}
		ret doc::ListItem{
			Mark: mark,
			Text: txt.Str(),
		}
	}

	fn next(*self): doc::Context {
		mut ctx := doc::Context{}
		mut line := self.lines[self.i]
		line, ctx.Indent, _ = handleDocLine(line, true)
		if len(line) == 0 {
			ctx.Node = doc::Separator(true)
			self.i++
			ret ctx
		}
		mark := isList(line)
		if len(mark) > 0 {
			ctx.Node = self.list(line, mark)
		} else {
			ctx.Node = self.text()
		}
		ret ctx
	}

	// Removes leading and trailing separator lines.
	fn simplifyLines(*self) {
		if len(self.lines) == 0 {
			ret
		}
		mut i := 0
		for i < len(self.lines); i++ {
			line, _, _ := handleDocLine(self.lines[i], true)
			if len(line) == 0 {
				continue
			}
			break
		}
		self.lines = self.lines[i:]
		if len(self.lines) == 0 {
			ret
		}
		i = len(self.lines) - 1
		for ; i-- {
			line, _, _ := handleDocLine(self.lines[i], true)
			if len(line) == 0 {
				continue
			}
			break
		}
		self.lines = self.lines[:i+1]
	}

	// Builds context from doc comments.
	fn build(*self, doc: str): []doc::Context {
		mut ctx := make([]doc::Context, 0)
		self.i = 0
		self.lines = strings::Split(doc, "\n")
		self.simplifyLines()
		mut sep := false // Previous iteration step added a separator.
		for self.i < len(self.lines) {
			mut lineCtx := self.next()
			match type lineCtx.Node {
			| doc::Separator:
				// Do not add duplicated seperators.
				if sep {
					continue
				}
				sep = true
			|:
				sep = false
			}
			ctx = append(ctx, lineCtx)
		}
		ret ctx
	}
}

// Removes leading spaces from doc comment and
// returns with indentation level of line.
// If ws true, ignores leading and trailing whitespaces.
// Returns ignored leading whitespace count as tws.
fn handleDocLine(mut line: str, ws: bool): (rest: str, indent: int, tws: int) {
	if len(line) == 0 {
		ret "", 0, 0
	}
	line = line[2:] // Remove comment prefix.
	if len(line) == 0 {
		ret line, 0, 0
	}
	if line[0] == ' ' {
		line = line[1:]
		tws++
	}
	for _, r in line {
		if r != ' ' && unicode::IsSpace(r) {
			indent++
			continue
		}
		break
	}
	rest = line[indent:]
	if ws {
		// Ignore whitespaces, count leading ones for tws.
		mut i := 0
		for i < len(rest) && rest[i] == ' ' {
			i++
			tws++
		}
		rest = rest[i:]
		// Ignore trailing whitespaces.
		// Use "\t" to trim mixed tabs.
		rest = strings::Trim(rest, " \t")
	}
	ret
}

// Cheks line for list nodes and returns list mark string if any list node exist.
// Otherwise returns zero-length string.
fn isList(line: str): str {
	if len(line) == 0 {
		ret ""
	}
	if line[0] == '-' {
		ret "-"
	}
	mut i := 0
	for i < len(line); i++ {
		b := line[i]
		if '0' <= b && b <= '9' {
			continue
		} else if b == '.' && i > 0 {
			ret line[:i+1]
		} else {
			break
		}
	}
	ret ""
}